// Code generated by protoc-gen-validatex. DO NOT EDIT.

// versions:
//  protoc-gen-validatex v0.0.1-dev

package main

import (
	context "context"
	fmt "fmt"
	toml "github.com/BurntSushi/toml"
	i18n "github.com/nicksnyder/go-i18n/v2/i18n"
	validatex "github.com/protoc-gen/protoc-gen-validatex/pkg/validatex"
	language "golang.org/x/text/language"
	mail "net/mail"
	os "os"
	path "path"
	regexp "regexp"
	strings "strings"
)

func (x *SignInRequest) Validate(ctx context.Context) error {
	if x == nil {
		return nil
	}
	if validEmail(x.Email) != nil {
		localize, err := i18n.NewLocalizer(i18nBundle,
			validatex.GetValFromCtx(ctx, validatex.KeyXLang), validatex.GetValFromCtx(ctx, validatex.KeyAcceptLang)).
			Localize(&i18n.LocalizeConfig{MessageID: "EmailInvalid", TemplateData: map[string]string{"FieldName": "email"}})
		if err == nil {
			return fmt.Errorf(localize)
		}
		return fmt.Errorf("field email must be a valid email")
	}
	if len(x.Password) < 5 {
		return fmt.Errorf("field password must have at least 5 characters")
	}
	if len(x.Password) > 50 {
		return fmt.Errorf("field password must have at most 50 characters")
	}
	return nil
}

// validEmail checks if the email is valid
//
// According to RFC 5321:
// Path = Local-part@Domain
//
// 1. Path is up to 256 characters (including the punctuation and element separators)
//
// 2. Local-part is up to 64 characters
//
// 3. Domain is up to 255 characters
func validEmail(email string) error {
	addr, err := mail.ParseAddress(email)
	if err != nil {
		return err
	}

	if len(addr.Address) > 256 {
		return fmt.Errorf("email address is too long")
	}

	ss := strings.Split(addr.Address, "@")
	if len(ss) != 2 {
		return fmt.Errorf("missing '@' symbol")
	}

	if len(ss[0]) > 64 {
		return fmt.Errorf("part before '@' too long")
	}

	if len(ss[1]) > 255 {
		return fmt.Errorf("part after '@' too long")
	}

	if addr.Address != email {
		return fmt.Errorf("email address is not equal after parsing")
	}

	if !isValidDomain(ss[1]) {
		return fmt.Errorf("invalid domain")
	}

	return nil
}

func isValidDomain(domain string) bool {
	re := regexp.MustCompile(`^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
	return re.MatchString(domain)
}

var (
	i18nBundle = newI18n("./example/i18n")
)

func newI18n(dir string) *i18n.Bundle {
	bundle := i18n.NewBundle(language.English)
	bundle.RegisterUnmarshalFunc("toml", toml.Unmarshal)
	files, err := os.ReadDir(dir)
	if err != nil {
		panic(err)
	}
	for _, file := range files {
		if path.Ext(file.Name()) != ".toml" {
			continue
		}
		bundle.MustLoadMessageFile(path.Join(dir, file.Name()))
	}
	return bundle
}
