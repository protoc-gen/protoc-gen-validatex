package validatex

import (
	_ "embed"
	"github.com/protoc-gen/protoc-gen-validatex/version"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"strings"
)

const (
	contextPkg   = protogen.GoImportPath("context")
	i18nPkg      = protogen.GoImportPath("github.com/nicksnyder/go-i18n/v2/i18n")
	validatexPkg = protogen.GoImportPath("github.com/protoc-gen/protoc-gen-validatex/pkg/validatex")
)

func GenerateFile(gen *protogen.Plugin, file *protogen.File, i18nDir string) {
	filename := file.GeneratedFilenamePrefix + ".pb.validatex.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-validatex. DO NOT EDIT.")
	g.P()
	g.P("// versions:")
	g.P("//  protoc-gen-validatex ", version.Version)
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.QualifiedGoIdent(contextPkg.Ident(""))
	g.QualifiedGoIdent(i18nPkg.Ident(""))
	g.QualifiedGoIdent(validatexPkg.Ident(""))
	g.P()

	jsonName := isJSONName(gen)

	for _, message := range file.Messages {
		generate(g, message, jsonName)
	}

	g.P()
	g.P("func init() {")
	g.P("  validatex.Init18n(\"", i18nDir, "\")")
	g.P("}")
}

func generate(g *protogen.GeneratedFile, message *protogen.Message, jsonName bool) {
	g.P("func (x *", message.GoIdent, ") Validate(ctx context.Context) error {")
	g.P("  if x == nil {")
	g.P("    return nil")
	g.P("  }")
	for _, field := range message.Fields {
		generateField(g, field, jsonName)
	}
	g.P("  return nil")
	g.P("}")
}

func generateField(g *protogen.GeneratedFile, field *protogen.Field, jsonName bool) {
	goFieldName := "x." + field.GoName
	fieldName := string(field.Desc.Name())
	if jsonName {
		fieldName = field.Desc.JSONName()
	}

	options := field.Desc.Options()
	if options == nil {
		return
	}

	rules := proto.GetExtension(options, E_Rules).(*FieldRules)
	if rules == nil || rules.Type == nil {
		return
	}

	switch t := rules.Type.(type) {
	case *FieldRules_String_:
		stringRules := t.String_
		if stringRules.Email {
			g.P("  if validatex.ValidEmail(", goFieldName, ") != nil {")
			g.P("    return validatex.NewError(")
			g.P("      validatex.MustLocalize(ctx, &i18n.LocalizeConfig{MessageID: \"EmailInvalid\",")
			g.P("        TemplateData: map[string]string{\"FieldName\": \"", fieldName, "\"},")
			g.P("      }, \"must be a valid email\")).")
			g.P("      WithMetadata(map[string]string{\"field\": \"", fieldName, "\"})")
			g.P("  }")
		}
		if stringRules.MinLen > 0 {
			g.P("  if len(", goFieldName, ") < ", stringRules.MinLen, " {")
			g.P("    return validatex.NewError(")
			g.P("      validatex.MustLocalize(ctx, &i18n.LocalizeConfig{MessageID: \"StringMinLen\",")
			g.P("        TemplateData: map[string]string{\"MinLen\": \"", stringRules.MinLen, "\"},")
			g.P("      }, \"must be at least ", stringRules.MinLen, " characters long\")).")
			g.P("      WithMetadata(map[string]string{\"field\": \"", fieldName, "\"})")
			g.P("  }")
		}
		if stringRules.MaxLen > 0 {
			g.P("  if len(", goFieldName, ") > ", stringRules.MaxLen, " {")
			g.P("    return validatex.NewError(")
			g.P("      validatex.MustLocalize(ctx, &i18n.LocalizeConfig{MessageID: \"StringMaxLen\",")
			g.P("        TemplateData: map[string]string{\"MaxLen\": \"", stringRules.MaxLen, "\"},")
			g.P("      }, \"must be at most ", stringRules.MaxLen, " characters long\")).")
			g.P("      WithMetadata(map[string]string{\"field\": \"", fieldName, "\"})")
			g.P("  }")
		}
		if stringRules.ExactLen > 0 {
			g.P("  if len(", goFieldName, ") != ", stringRules.ExactLen, " {")
			g.P("    return validatex.NewError(")
			g.P("      validatex.MustLocalize(ctx, &i18n.LocalizeConfig{MessageID: \"StringExactLen\",")
			g.P("        TemplateData: map[string]string{\"ExactLen\": \"", stringRules.ExactLen, "\"},")
			g.P("      }, \"must be exactly ", stringRules.ExactLen, " characters long\")).")
			g.P("      WithMetadata(map[string]string{\"field\": \"", fieldName, "\"})")
			g.P("  }")
		}
		if stringRules.NonEmpty {
			g.P("  if len(", goFieldName, ") == 0 {")
			g.P("    return validatex.NewError(")
			g.P("      validatex.MustLocalize(ctx, &i18n.LocalizeConfig{MessageID: \"StringNonEmpty\",")
			g.P("      }, \"must not be empty\")).")
			g.P("      WithMetadata(map[string]string{\"field\": \"", fieldName, "\"})")
			g.P("  }")
		}
		if stringRules.Uuid {
			g.P("  if !validatex.ValidUUID(", goFieldName, ") {")
			g.P("    return validatex.NewError(")
			g.P("      validatex.MustLocalize(ctx, &i18n.LocalizeConfig{MessageID: \"UUIDInvalid\",")
			g.P("        TemplateData: map[string]string{\"FieldName\": \"", fieldName, "\"},")
			g.P("      }, \"must be a valid UUID\")).")
			g.P("      WithMetadata(map[string]string{\"field\": \"", fieldName, "\"})")
			g.P("  }")
		}
	}
}

func isJSONName(gen *protogen.Plugin) bool {
	parts := strings.Split(gen.Request.GetParameter(), ",")

	for _, part := range parts {
		if strings.HasPrefix(part, "json_name=") {
			jsonName := strings.TrimPrefix(part, "json_name=")
			if strings.ToLower(jsonName) == "true" {
				return true
			}
		}
	}

	return false
}
