package validatex

import (
	_ "embed"
	"github.com/protoc-gen/protoc-gen-validatex/version"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

const (
	pkgFmt     = protogen.GoImportPath("fmt")
	mailPkg    = protogen.GoImportPath("net/mail")
	stringsPkg = protogen.GoImportPath("strings")
	regexpPkg  = protogen.GoImportPath("regexp")
)

var (
	//go:embed ValidEmail
	validEmailFunc string
)

func GenerateFile(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + ".pb.validatex.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-validatex. DO NOT EDIT.")
	g.P()
	g.P("// versions:")
	g.P("//  protoc-gen-validatex ", version.Version)
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.QualifiedGoIdent(pkgFmt.Ident(""))
	g.QualifiedGoIdent(mailPkg.Ident(""))
	g.QualifiedGoIdent(stringsPkg.Ident(""))
	g.QualifiedGoIdent(regexpPkg.Ident(""))

	for _, message := range file.Messages {
		generate(g, message)
	}

	g.P()
	g.P(validEmailFunc)
}

func generate(g *protogen.GeneratedFile, message *protogen.Message) {
	g.P("func (x *", message.GoIdent, ") Validate() error {")
	g.P("  if x == nil {")
	g.P("    return nil")
	g.P("  }")
	for _, field := range message.Fields {
		generateField(g, field)
	}
	g.P("  return nil")
	g.P("}")
}

func generateField(g *protogen.GeneratedFile, field *protogen.Field) {
	fieldName := "x." + field.GoName

	options := field.Desc.Options()
	if options == nil {
		return
	}

	rules := proto.GetExtension(options, E_Rules).(*FieldRules)
	if rules == nil || rules.Type == nil {
		return
	}

	switch t := rules.Type.(type) {
	case *FieldRules_String_:
		stringRules := t.String_
		if stringRules.Email {
			g.P("  if validEmail(", fieldName, ") != nil {")
			g.P("    return fmt.Errorf(\"field ", field.Desc.Name(), " must be a valid email\")")
			g.P("  }")
		}
		if stringRules.MinLen > 0 {
			g.P("  if len(", fieldName, ") < ", stringRules.MinLen, " {")
			g.P("    return fmt.Errorf(\"field ", field.Desc.Name(), " must have at least ", stringRules.MinLen, " characters\")")
			g.P("  }")
		}
		if stringRules.MaxLen > 0 {
			g.P("  if len(", fieldName, ") > ", stringRules.MaxLen, " {")
			g.P("    return fmt.Errorf(\"field ", field.Desc.Name(), " must have at most ", stringRules.MaxLen, " characters\")")
			g.P("  }")
		}
	}
}
